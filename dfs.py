def build_graph(edges):
    """
    Строит граф из списка рёбер
    
    Параметры:
    edges -- список пар вершин, представляющих рёбра графа
    
    Возвращает:
    словарь, где ключи - вершины, а значения - списки смежных вершин
    """
    # Инициализация пустого графа
    graph = {}
    
    # Для каждого ребра добавляем связь в граф
    for u, v in edges:
        # Если вершина u еще не в графе, добавляем её
        if u not in graph:
            graph[u] = []
        # Если вершина v еще не в графе, добавляем её
        if v not in graph:
            graph[v] = []
        # Добавляем связь от u к v
        graph[u].append(v)
    
    return graph

def dfs(graph, start):
    """
    Выполняет обход графа в глубину и возвращает путь обхода
    
    Параметры:
    graph -- граф в виде словаря смежности
    start -- начальная вершина обхода
    
    Возвращает:
    список вершин в порядке обхода
    
    Исключения:
    ValueError -- если начальная вершина отсутствует в графе
    """
    # Проверка на корректность входного параметра
    if start not in graph:
        raise ValueError(f"Вершина {start} отсутствует в графе")
    
    visited = []  # Список посещенных вершин
    stack = [start]  # Стек вершин для обхода
    
    # Продолжаем обход, пока стек не пуст
    while stack:
        # Извлекаем вершину из стека (LIFO - последний вошел, первый вышел)
        vertex = stack.pop()  # Извлекаем вершину из стека
        
        # Если вершина еще не посещена
        if vertex not in visited:
            visited.append(vertex)  # Отмечаем вершину как посещенную
            
            # Добавляем соседей в обратном порядке, чтобы обход происходил в порядке возрастания
            if vertex in graph:
                # Сортируем соседей по убыванию, чтобы при извлечении из стека они шли в порядке возрастания
                neighbors = sorted(graph[vertex], reverse=True)
                stack.extend(neighbors)  # Добавляем соседей в стек
    
    return visited

def find_path_length(graph, start, end):
    """
    Находит длину пути от вершины start до вершины end
    
    Параметры:
    graph -- граф в виде словаря смежности
    start -- начальная вершина
    end -- конечная вершина
    
    Возвращает:
    целое число - длина кратчайшего пути или -1, если путь не существует
    
    Исключения:
    ValueError -- если начальная или конечная вершина отсутствует в графе
    """
    # Проверка на корректность входных параметров
    if start not in graph:
        raise ValueError(f"Начальная вершина {start} отсутствует в графе")
    if end not in graph:
        raise ValueError(f"Конечная вершина {end} отсутствует в графе")
    
    # Если начальная и конечная вершины совпадают, длина пути равна 0
    if start == end:
        return 0
    
    visited = set()  # Множество посещенных вершин для быстрой проверки
    queue = [(start, 0)]  # Очередь (вершина, длина пути до неё)
    
    # Алгоритм поиска в ширину (BFS) для нахождения кратчайшего пути
    while queue:
        # Извлекаем вершину и длину пути из начала очереди (FIFO - первый вошел, первый вышел)
        vertex, length = queue.pop(0)  # Извлекаем вершину и длину пути из очереди
        
        # Если достигли конечной вершины, возвращаем длину пути
        if vertex == end:
            return length  # Нашли конечную вершину
        
        # Если вершина еще не была посещена
        if vertex not in visited:
            visited.add(vertex)  # Отмечаем вершину как посещенную
            
            # Добавляем всех не посещенных соседей в очередь
            if vertex in graph:
                for neighbor in graph[vertex]:
                    if neighbor not in visited:
                        # Добавляем соседа с увеличенной на 1 длиной пути
                        queue.append((neighbor, length + 1))  # Добавляем соседей в очередь
    
    # Если мы обошли весь достижимый граф и не нашли конечную вершину
    return -1  # Путь не найден

def main():
    """
    Основная функция программы
    """
    # Выводим инструкцию для пользователя
    print("Введите рёбра графа в формате 'вершина1 вершина2' (по одному ребру на строку, пустая строка для завершения):")
    edges_input = input()
    edges = []
    
    # Парсим ввод пользователя, собирая рёбра графа
    while edges_input:
        try:
            # Преобразуем ввод пользователя в пару чисел
            u, v = map(int, edges_input.split())
            edges.append((u, v))
        except ValueError:
            # Обрабатываем некорректный ввод
            print("Ошибка: введите два целых числа, разделенных пробелом")
        edges_input = input()
    
    # Строим граф из списка рёбер
    graph = build_graph(edges)
    
    # Запрашиваем у пользователя режим работы
    choice = input("Выберите режим (1 - обход графа, 2 - найти длину пути): ")
    
    # Обрабатываем выбор пользователя
    if choice == "1":
        try:
            # Режим обхода графа в глубину
            start_vertex = int(input("Введите стартовую вершину: "))
            path = dfs(graph, start_vertex)
            print(f"Путь обхода: {', '.join(map(str, path))}")
        except ValueError as e:
            # Обрабатываем ошибки, которые могут возникнуть при обходе
            print(f"Ошибка: {e}")
    elif choice == "2":
        try:
            # Режим нахождения длины пути
            start_vertex = int(input("Введите начальную вершину: "))
            end_vertex = int(input("Введите конечную вершину: "))
            path_length = find_path_length(graph, start_vertex, end_vertex)
            
            # Выводим результат в зависимости от того, найден ли путь
            if path_length >= 0:
                print(f"Длина пути от вершины {start_vertex} до вершины {end_vertex}: {path_length}")
            else:
                print(f"Путь от вершины {start_vertex} до вершины {end_vertex} не существует")
        except ValueError as e:
            # Обрабатываем ошибки, которые могут возникнуть при поиске пути
            print(f"Ошибка: {e}")
    else:
        # Обрабатываем некорректный выбор режима
        print("Некорректный выбор режима")

# Точка входа в программу
if __name__ == "__main__":
    main()